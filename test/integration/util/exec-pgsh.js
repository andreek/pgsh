const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { spawn } = require('child_process');

const pick = require('lodash.pick');
const stripAnsiStream = require('strip-ansi-stream');

const debug = require('debug')('integration:util:exec-pgsh');

const PGSH_PATH = require('./find-pgsh')();
const stringifyEnv = require('../../../src/util/stringify-env');

module.exports = (workingDirectory, args, config, env) => {
  const cwd = workingDirectory.startsWith('/')
    ? workingDirectory
    : path.resolve(workingDirectory);

  const ENV_PATH = path.join(cwd, '.env');
  if (env) {
    fs.writeFileSync(
      ENV_PATH,
      `# generated by pgsh\n\n${stringifyEnv(env)}\n`,
      { encoding: 'utf8' },
    );
  } else {
    fs.unlinkSync(ENV_PATH);
  }

  const PGSHRC_PATH = path.join(cwd, '.pgshrc');
  if (config) {
    fs.writeFileSync(
      PGSHRC_PATH,
      `${JSON.stringify(config, null, 2)}\n`,
      { encoding: 'utf8' },
    );
  } else {
    fs.unlinkSync(PGSHRC_PATH);
  }

  const pgsh = spawn(PGSH_PATH, args, {
    cwd,
    shell: true,
  });

  const exitCode = new Promise((resolve) => {
    pgsh.on('close', (code) => {
      debug(`child process exited with code ${code}`);
      resolve(code);
    });
  });

  pgsh.stderr.setEncoding('utf8');
  pgsh.stdout.setEncoding('utf8');

  const rl = readline.createInterface(
    pgsh.stdout.pipe(stripAnsiStream()),
  );
  const output = rl[Symbol.asyncIterator]();

  const sendKey = keyCode => pgsh.stdin.write(String.fromCharCode(keyCode));

  return {
    exitCode,
    output,
    respond: text => pgsh.stdin.write(`${text}\n`),
    send: {
      left: () => sendKey(37),
      up: () => sendKey(38),
      right: () => sendKey(39),
      down: () => sendKey(40),
      enter: () => sendKey(13),
      ctrlC: () => sendKey(3),
    },
    ...pick(pgsh, ['stdin', 'stderr']),
  };
};
